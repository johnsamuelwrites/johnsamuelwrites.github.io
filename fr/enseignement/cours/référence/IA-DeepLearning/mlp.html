<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Visualisation MLP - Apprentissage par lot vs stochastique</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                display: flex;
                justify-content: center;
                align-items: center;
                min-height: 100vh;
                padding: 20px;
            }

            .container {
                background: white;
                border-radius: 20px;
                padding: 30px;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                width: 95vw;
                max-width: 1400px;
            }

            h1 {
                text-align: center;
                color: #333;
                margin-bottom: 10px;
                font-size: 28px;
            }

            .subtitle {
                text-align: center;
                color: #666;
                margin-bottom: 20px;
                font-size: 14px;
            }

            .learning-mode-selector {
                background: #e3f2fd;
                padding: 20px;
                border-radius: 10px;
                margin-bottom: 20px;
                border: 2px solid #2196F3;
            }

            .learning-mode-selector h3 {
                color: #1976d2;
                margin-bottom: 15px;
                font-size: 18px;
            }

            .mode-options {
                display: flex;
                gap: 20px;
                flex-wrap: wrap;
            }

            .mode-option {
                flex: 1;
                min-width: 250px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                cursor: pointer;
                border: 3px solid transparent;
                transition: all 0.3s;
            }

            .mode-option:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            }

            .mode-option.selected {
                border-color: #2196F3;
                background: #f0f7ff;
            }

            .mode-option input[type="radio"] {
                margin-right: 10px;
            }

            .mode-option h4 {
                color: #333;
                margin-bottom: 8px;
                font-size: 16px;
            }

            .mode-option p {
                color: #666;
                font-size: 13px;
                line-height: 1.5;
            }

            .controls {
                display: flex;
                justify-content: center;
                gap: 15px;
                margin-bottom: 20px;
                flex-wrap: wrap;
            }

            button {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border: none;
                padding: 12px 30px;
                border-radius: 25px;
                cursor: pointer;
                font-size: 16px;
                font-weight: 600;
                transition: transform 0.2s, box-shadow 0.2s;
                box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            }

            button:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
            }

            button:disabled {
                background: #ccc;
                cursor: not-allowed;
                box-shadow: none;
            }

            #networkCanvas {
                display: block;
                margin: 0 auto;
                background: #f8f9fa;
                border-radius: 10px;
                border: 2px solid #e0e0e0;
            }

            .current-step {
                background: #fff3cd;
                border: 2px solid #ffc107;
                padding: 15px;
                border-radius: 10px;
                margin-bottom: 15px;
                text-align: center;
            }

            .current-step h3 {
                color: #856404;
                font-size: 16px;
                margin-bottom: 5px;
            }

            .current-step p {
                color: #856404;
                font-size: 14px;
                margin: 0;
            }

            .formula-display {
                background: #e3f2fd;
                padding: 10px;
                border-radius: 5px;
                margin-top: 5px;
                font-family: 'Courier New', monospace;
                font-size: 13px;
                color: #0d47a1;
            }

            .error-accumulator {
                background: #ffe0e0;
                border: 2px solid #f44336;
                padding: 15px;
                border-radius: 10px;
                margin-bottom: 15px;
            }

            .error-accumulator h3 {
                color: #c62828;
                font-size: 16px;
                margin-bottom: 10px;
            }

            .error-samples {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 10px;
            }

            .error-sample {
                background: white;
                padding: 10px;
                border-radius: 5px;
                font-size: 13px;
            }

            .error-sample.processed {
                background: #c8e6c9;
                border: 2px solid #4caf50;
            }

            .error-sample .sample-label {
                font-weight: bold;
                color: #333;
                margin-bottom: 5px;
            }

            .error-sample .sample-loss {
                color: #f44336;
                font-family: monospace;
            }

            .stats-panel {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 15px;
                margin-top: 15px;
            }

            .stat-box {
                background: #fff;
                padding: 15px;
                border-radius: 8px;
                border: 2px solid #e0e0e0;
                text-align: center;
            }

            .stat-label {
                font-size: 12px;
                color: #666;
                margin-bottom: 5px;
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .stat-value {
                font-size: 24px;
                font-weight: bold;
                color: #667eea;
            }

            .legend {
                display: flex;
                justify-content: center;
                gap: 30px;
                margin-top: 15px;
                flex-wrap: wrap;
            }

            .legend-item {
                display: flex;
                align-items: center;
                gap: 8px;
                font-size: 13px;
                color: #555;
            }

            .legend-color {
                width: 20px;
                height: 20px;
                border-radius: 50%;
                border: 2px solid #333;
            }

            .info-panel {
                margin-top: 20px;
                padding: 20px;
                background: #f0f4ff;
                border-radius: 10px;
                border-left: 4px solid #667eea;
            }

            .info-panel h3 {
                color: #333;
                margin-bottom: 10px;
                font-size: 18px;
            }

            .info-panel p {
                color: #555;
                line-height: 1.8;
                font-size: 14px;
                margin-bottom: 10px;
            }

            .info-panel strong {
                color: #667eea;
            }

            .speed-control {
                display: flex;
                align-items: center;
                gap: 10px;
                font-size: 14px;
                color: #555;
            }

            .weight-tooltip {
                position: absolute;
                background: rgba(0, 0, 0, 0.9);
                color: white;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 12px;
                pointer-events: none;
                z-index: 1000;
                display: none;
                white-space: nowrap;
            }
        </style>
    </head>

    <body>
        <div class="weight-tooltip" id="tooltip"></div>

        <div class="container">
            <h1>üß† Apprentissage perceptron multi-couche (MLP) : par lot vs descente de gradient stochastique</h1>
            <p class="subtitle">Comprendre la gestion des erreurs pendant l'entra√Ænement</p>

            <div class="learning-mode-selector">
                <h3>Choisissez le mode d'apprentissage :</h3>
                <div class="mode-options">
                    <label class="mode-option selected" id="modeStochastic">
                        <input type="radio" name="learningMode" value="stochastic" checked
                            onchange="selectMode('stochastic')">
                        <h4>üéØ Descente de gradient stochastique (SGD)</h4>
                        <p><strong>Mettre √† jour apr√®s CHAQUE √©chantillon</strong><br>
                            ‚Ä¢ Mises √† jour plus rapides et fr√©quentes<br>
                            ‚Ä¢ Les poids changent apr√®s chaque exemple d'entra√Ænement<br>
                            ‚Ä¢ Bruyant mais capable d‚Äô√©chapper aux minima locaux<br>
                            ‚Ä¢ Perte actuelle affich√©e par √©chantillon</p>
                    </label>
                    <label class="mode-option" id="modeBatch">
                        <input type="radio" name="learningMode" value="batch" onchange="selectMode('batch')">
                        <h4>üì¶ Descente de gradient par lot</h4>
                        <p><strong>Mettre √† jour UNE FOIS par √©poque</strong><br>
                            ‚Ä¢ Accumuler les gradients de tous les √©chantillons<br>
                            ‚Ä¢ Les poids sont mis √† jour apr√®s avoir trait√© toutes les donn√©es<br>
                            ‚Ä¢ Direction du gradient stable et coh√©rente<br>
                            ‚Ä¢ Perte moyenne sur tous les √©chantillons</p>
                    </label>
                </div>
            </div>

            <div class="current-step" id="stepIndicator">
                <h3 id="stepTitle">Pr√™t √† d√©marrer</h3>
                <p id="stepDescription">S√©lectionnez un mode d'apprentissage et cliquez sur "Entra√Æner le r√©seau"</p>
                <div class="formula-display" id="formulaDisplay" style="display: none;"></div>
            </div>

            <div class="error-accumulator" id="errorAccumulator" style="display: none;">
                <h3>üìä Suivi des erreurs pour l'√©poque en cours</h3>
                <div class="error-samples" id="errorSamples"></div>
                <div style="margin-top: 10px; font-size: 14px; color: #c62828;">
                    <strong>Perte totale accumul√©e :</strong> <span id="totalLoss">0.0000</span>
                </div>
            </div>

            <div class="controls">
                <button id="trainBtn" onclick="startTraining()">üéì Entra√Æner le r√©seau (1 √©poque)</button>
                <button id="forwardBtn" onclick="startForwardProp()">‚ñ∂Ô∏è Passage avant seulement</button>
                <button id="resetBtn" onclick="resetNetwork()">üîÑ R√©initialiser le r√©seau</button>
                <button id="randomBtn" onclick="randomizeWeights()">üé≤ Randomiser les poids</button>
                <div class="speed-control">
                    <label for="speedSlider">Vitesse :</label>
                    <input type="range" id="speedSlider" min="0.3" max="2" step="0.1" value="1">
                    <span id="speedValue">1.0x</span>
                </div>
            </div>

            <div class="stats-panel">
                <div class="stat-box">
                    <div class="stat-label">Mode d'apprentissage</div>
                    <div class="stat-value" id="modeValue" style="font-size: 16px;">SGD</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Phase actuelle</div>
                    <div class="stat-value" id="phaseValue" style="font-size: 16px;">Pr√™t</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Perte moyenne</div>
                    <div class="stat-value" id="lossValue">0.0000</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">√âpoques compl√©t√©es</div>
                    <div class="stat-value" id="epochValue">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Mises √† jour des poids</div>
                    <div class="stat-value" id="updateValue">0</div>
                </div>
            </div>

            <canvas id="networkCanvas" width="1300" height="500"></canvas>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>Couche d'entr√©e</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #2196F3;"></div>
                    <span>Couche cach√©e</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF9800;"></div>
                    <span>Couche de sortie</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(255, 50, 50, 0.8);"></div>
                    <span>Signal avant</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(255, 215, 0, 0.8);"></div>
                    <span>Gradient arri√®re</span>
                </div>
            </div>

            <div class="info-panel">
                <h3>üìö Comprendre la gestion des erreurs en une √©poque :</h3>

                <p><strong>Descente de gradient stochastique (SGD) :</strong></p>
                <p>‚Ä¢ Traiter l‚Äô√©chantillon 1 ‚Üí Calculer l‚Äôerreur ‚Üí Mettre √† jour les poids imm√©diatement<br>
                    ‚Ä¢ Traiter l‚Äô√©chantillon 2 ‚Üí Calculer l‚Äôerreur ‚Üí Mettre √† jour les poids imm√©diatement<br>
                    ‚Ä¢ Traiter l‚Äô√©chantillon 3 ‚Üí Calculer l‚Äôerreur ‚Üí Mettre √† jour les poids imm√©diatement<br>
                    ‚Ä¢ Traiter l‚Äô√©chantillon 4 ‚Üí Calculer l‚Äôerreur ‚Üí Mettre √† jour les poids imm√©diatement<br>
                    <strong>R√©sultat :</strong> 4 mises √† jour des poids par √©poque. Chaque √©chantillon influence
                    imm√©diatement le r√©seau.
                </p>

                <p><strong>Descente de gradient par lot :</strong></p>
                <p>‚Ä¢ Traiter l‚Äô√©chantillon 1 ‚Üí Calculer l‚Äôerreur ‚Üí Stocker les gradients<br>
                    ‚Ä¢ Traiter l‚Äô√©chantillon 2 ‚Üí Calculer l‚Äôerreur ‚Üí Accumuler les gradients<br>
                    ‚Ä¢ Traiter l‚Äô√©chantillon 3 ‚Üí Calculer l‚Äôerreur ‚Üí Accumuler les gradients<br>
                    ‚Ä¢ Traiter l‚Äô√©chantillon 4 ‚Üí Calculer l‚Äôerreur ‚Üí Accumuler les gradients<br>
                    ‚Ä¢ Moyenne de tous les gradients ‚Üí Mettre √† jour les poids UNE FOIS<br>
                    <strong>R√©sultat :</strong> 1 mise √† jour des poids par √©poque. Tous les √©chantillons influencent la
                    mise √† jour de mani√®re √©gale.
                </p>

                <p><strong>Diff√©rence cl√© :</strong> En SGD, les poids changent apr√®s chaque √©chantillon, donc les
                    √©chantillons suivants voient des poids diff√©rents des premiers. En Descente de gradient par lot,
                    tous les √©chantillons voient les m√™mes poids et nous mettons √† jour en fonction du gradient moyen.
                </p>

                <p><strong>Calcul de la perte moyenne :</strong> Pour les deux m√©thodes, on rapporte la perte moyenne
                    sur tous les √©chantillons de l‚Äô√©poque :
                    <code>Perte Moyenne = (Perte‚ÇÅ + Perte‚ÇÇ + Perte‚ÇÉ + Perte‚ÇÑ) / 4</code>
                </p>
            </div>
        </div>

        <script>
            const canvas = document.getElementById('networkCanvas');
            const ctx = canvas.getContext('2d');
            const tooltip = document.getElementById('tooltip');

            // Network architecture
            const layers = [3, 4, 2];
            const layerColors = ['#4CAF50', '#2196F3', '#FF9800'];

            // State
            let neurons = [];
            let connections = [];
            let animating = false;
            let animationSpeed = 1;
            let learningRate = 0.5;
            let epochCount = 0;
            let currentLoss = 0;
            let learningMode = 'stochastic'; // 'stochastic' or 'batch'
            let totalWeightUpdates = 0;

            // Training data
            const trainingData = [
                { input: [0.2, 0.3, 0.1], target: [0.8, 0.2] },
                { input: [0.8, 0.7, 0.9], target: [0.2, 0.8] },
                { input: [0.1, 0.8, 0.2], target: [0.7, 0.3] },
                { input: [0.9, 0.2, 0.8], target: [0.3, 0.7] }
            ];

            function selectMode(mode) {
                if (animating) return;

                learningMode = mode;
                document.getElementById('modeStochastic').classList.toggle('selected', mode === 'stochastic');
                document.getElementById('modeBatch').classList.toggle('selected', mode === 'batch');
                document.getElementById('modeValue').textContent = mode === 'stochastic' ? 'SGD' : 'Batch';
            }

            function initNetwork() {
                neurons = [];
                connections = [];

                const layerSpacing = canvas.width / (layers.length + 1);

                layers.forEach((count, layerIndex) => {
                    const layer = [];
                    const neuronSpacing = canvas.height / (count + 1);

                    for (let i = 0; i < count; i++) {
                        layer.push({
                            x: layerSpacing * (layerIndex + 1),
                            y: neuronSpacing * (i + 1),
                            radius: 25,
                            activation: 0,
                            delta: 0,
                            accumulatedDelta: 0, // For batch mode
                            color: layerColors[layerIndex],
                            layer: layerIndex,
                            index: i,
                            computing: false,
                            weightedSum: 0
                        });
                    }
                    neurons.push(layer);
                });

                for (let l = 0; l < neurons.length - 1; l++) {
                    for (let i = 0; i < neurons[l].length; i++) {
                        for (let j = 0; j < neurons[l + 1].length; j++) {
                            connections.push({
                                from: neurons[l][i],
                                to: neurons[l + 1][j],
                                weight: (Math.random() * 2 - 1) * 0.5,
                                signal: 0,
                                backSignal: 0,
                                accumulatedGradient: 0, // For batch mode
                                active: false
                            });
                        }
                    }
                }

                updateStats();
            }

            function updateStats() {
                document.getElementById('epochValue').textContent = epochCount;
                document.getElementById('lossValue').textContent = currentLoss.toFixed(4);
                document.getElementById('updateValue').textContent = totalWeightUpdates;
            }

            function updateStepIndicator(title, description, formula = null) {
                document.getElementById('stepTitle').textContent = title;
                document.getElementById('stepDescription').textContent = description;

                const formulaDisplay = document.getElementById('formulaDisplay');
                if (formula) {
                    formulaDisplay.textContent = formula;
                    formulaDisplay.style.display = 'block';
                } else {
                    formulaDisplay.style.display = 'none';
                }
            }

            function updateErrorAccumulator(sampleIndex, loss, isProcessed) {
                const accumulator = document.getElementById('errorAccumulator');
                const samplesDiv = document.getElementById('errorSamples');

                accumulator.style.display = 'block';

                let sampleDiv = document.getElementById(`error-sample-${sampleIndex}`);
                if (!sampleDiv) {
                    sampleDiv = document.createElement('div');
                    sampleDiv.id = `error-sample-${sampleIndex}`;
                    sampleDiv.className = 'error-sample';
                    samplesDiv.appendChild(sampleDiv);
                }

                sampleDiv.innerHTML = `
                    <div class="sample-label">√âchantillon ${sampleIndex + 1}</div>
                    <div class="sample-loss">Perte : ${loss.toFixed(4)}</div>
                `;


                if (isProcessed) {
                    sampleDiv.classList.add('processed');
                }
            }

            function clearErrorAccumulator() {
                document.getElementById('errorSamples').innerHTML = '';
                document.getElementById('totalLoss').textContent = '0.0000';
            }

            function drawNetwork() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw connections
                connections.forEach(conn => {
                    const weightMag = Math.abs(conn.weight);
                    const alpha = Math.min(weightMag / 2, 0.8);
                    let width = Math.max(1, Math.min(weightMag * 2.5, 6));

                    if (conn.active) width = 8;

                    ctx.beginPath();
                    ctx.moveTo(conn.from.x, conn.from.y);
                    ctx.lineTo(conn.to.x, conn.to.y);

                    if (conn.active) {
                        ctx.strokeStyle = 'rgba(255, 215, 0, 0.9)';
                    } else {
                        ctx.strokeStyle = conn.weight > 0
                            ? `rgba(33, 150, 243, ${alpha})`
                            : `rgba(244, 67, 54, ${alpha})`;
                    }
                    ctx.lineWidth = width;
                    ctx.stroke();

                    // Signals
                    if (conn.signal > 0 && conn.signal <= 1) {
                        const t = conn.signal;
                        const x = conn.from.x + (conn.to.x - conn.from.x) * t;
                        const y = conn.from.y + (conn.to.y - conn.from.y) * t;

                        ctx.beginPath();
                        ctx.arc(x, y, 10, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 50, 50, 0.9)';
                        ctx.fill();
                    }

                    if (conn.backSignal > 0 && conn.backSignal <= 1) {
                        const t = 1 - conn.backSignal;
                        const x = conn.from.x + (conn.to.x - conn.from.x) * t;
                        const y = conn.from.y + (conn.to.y - conn.from.y) * t;

                        ctx.beginPath();
                        ctx.arc(x, y, 10, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                        ctx.fill();
                    }
                });

                // Draw neurons
                neurons.forEach((layer, layerIndex) => {
                    layer.forEach(neuron => {
                        if (neuron.computing) {
                            ctx.beginPath();
                            ctx.arc(neuron.x, neuron.y, neuron.radius * 1.5, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                            ctx.fill();
                        }

                        ctx.beginPath();
                        ctx.arc(neuron.x, neuron.y, neuron.radius, 0, Math.PI * 2);
                        ctx.fillStyle = neuron.color;
                        ctx.fill();

                        if (neuron.activation > 0.1) {
                            const brightness = Math.min(neuron.activation, 1);
                            const gradient = ctx.createRadialGradient(
                                neuron.x, neuron.y, neuron.radius * 0.3,
                                neuron.x, neuron.y, neuron.radius * 1.3
                            );
                            gradient.addColorStop(0, `rgba(255, 255, 255, ${brightness * 0.9})`);
                            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                            ctx.beginPath();
                            ctx.arc(neuron.x, neuron.y, neuron.radius * 1.3, 0, Math.PI * 2);
                            ctx.fillStyle = gradient;
                            ctx.fill();
                        }

                        ctx.beginPath();
                        ctx.arc(neuron.x, neuron.y, neuron.radius, 0, Math.PI * 2);
                        ctx.strokeStyle = neuron.computing ? '#FFD700' : '#333';
                        ctx.lineWidth = neuron.computing ? 3 : 2;
                        ctx.stroke();

                        ctx.fillStyle = neuron.activation > 0.5 ? '#fff' : '#000';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        if (neuron.activation > 0) {
                            ctx.fillText(neuron.activation.toFixed(2), neuron.x, neuron.y);
                        }
                    });

                    const firstNeuron = layer[0];
                    const layerNames = ['Entr√©e', 'Cach√©e', 'Sortie'];
                    ctx.fillStyle = '#333';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(layerNames[layerIndex], firstNeuron.x, 35);
                });
            }

            function sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }

            function sigmoidDerivative(activation) {
                return activation * (1 - activation);
            }

            async function forwardPropagate(input, animate = true) {
                neurons[0].forEach((neuron, i) => {
                    neuron.activation = input[i] || 0;
                });

                if (animate) {
                    drawNetwork();
                    await sleep(500 / animationSpeed);
                }

                for (let l = 0; l < neurons.length - 1; l++) {
                    const fromLayer = neurons[l];
                    const toLayer = neurons[l + 1];
                    const layerConnections = connections.filter(
                        c => c.from.layer === l && c.to.layer === l + 1
                    );

                    if (animate) {
                        const steps = 30;
                        for (let step = 0; step <= steps; step++) {
                            layerConnections.forEach(conn => conn.signal = step / steps);
                            drawNetwork();
                            await sleep(10 / animationSpeed);
                        }
                        layerConnections.forEach(conn => conn.signal = 0);
                    }

                    toLayer.forEach(toNeuron => {
                        let sum = 0;
                        fromLayer.forEach(fromNeuron => {
                            const conn = layerConnections.find(
                                c => c.from === fromNeuron && c.to === toNeuron
                            );
                            if (conn) {
                                sum += fromNeuron.activation * conn.weight;
                            }
                        });
                        toNeuron.activation = sigmoid(sum);
                    });

                    if (animate) {
                        drawNetwork();
                        await sleep(300 / animationSpeed);
                    }
                }

                return neurons[neurons.length - 1].map(n => n.activation);
            }

            async function backPropagate(target, animate = true, updateWeights = true) {
                const outputLayer = neurons[neurons.length - 1];

                outputLayer.forEach((neuron, i) => {
                    const error = target[i] - neuron.activation;
                    neuron.delta = error * sigmoidDerivative(neuron.activation);
                });

                if (animate) {
                    drawNetwork();
                    await sleep(500 / animationSpeed);
                }

                for (let l = neurons.length - 2; l >= 0; l--) {
                    const currentLayer = neurons[l];
                    const nextLayer = neurons[l + 1];
                    const layerConnections = connections.filter(
                        c => c.from.layer === l && c.to.layer === l + 1
                    );

                    if (animate) {
                        const steps = 30;
                        for (let step = 0; step <= steps; step++) {
                            layerConnections.forEach(conn => conn.backSignal = step / steps);
                            drawNetwork();
                            await sleep(10 / animationSpeed);
                        }
                        layerConnections.forEach(conn => conn.backSignal = 0);
                    }

                    for (let i = 0; i < currentLayer.length; i++) {
                        const neuron = currentLayer[i];
                        let errorSum = 0;

                        for (let j = 0; j < nextLayer.length; j++) {
                            const nextNeuron = nextLayer[j];
                            const conn = layerConnections.find(
                                c => c.from === neuron && c.to === nextNeuron
                            );

                            if (conn) {
                                errorSum += nextNeuron.delta * conn.weight;

                                const gradient = neuron.activation * nextNeuron.delta;

                                if (updateWeights) {
                                    // SGD: update immediately
                                    conn.weight += learningRate * gradient;
                                } else {
                                    // Batch: accumulate gradient
                                    conn.accumulatedGradient += gradient;
                                }
                            }
                        }

                        neuron.delta = errorSum * sigmoidDerivative(neuron.activation);
                    }

                    if (animate) {
                        drawNetwork();
                        await sleep(200 / animationSpeed);
                    }
                }

                if (updateWeights) {
                    totalWeightUpdates++;
                    updateStats();
                }
            }

            function applyBatchUpdate() {
                // Apply accumulated gradients (divided by number of samples)
                const numSamples = trainingData.length;
                connections.forEach(conn => {
                    conn.weight += learningRate * (conn.accumulatedGradient / numSamples);
                    conn.accumulatedGradient = 0;
                });
                totalWeightUpdates++;
                updateStats();
            }

            function calculateLoss(output, target) {
                let loss = 0;
                for (let i = 0; i < output.length; i++) {
                    loss += Math.pow(target[i] - output[i], 2);
                }
                return loss / output.length;
            }

            async function startForwardProp() {
                if (animating) return;

                animating = true;
                document.getElementById('trainBtn').disabled = true;
                document.getElementById('forwardBtn').disabled = true;

                updateStepIndicator('‚ñ∂Ô∏è Passage avant seulement', 'Affichage du flux des entr√©es √† travers le r√©seau');

                const sample = trainingData[0];
                await forwardPropagate(sample.input, true);

                const output = neurons[neurons.length - 1].map(n => n.activation);
                currentLoss = calculateLoss(output, sample.target);
                updateStats();

                updateStepIndicator(
                    '‚úÖ Passage avant termin√©',
                    `Sortie : [${output.map(v => v.toFixed(3)).join(', ')}] | Perte : ${currentLoss.toFixed(4)}`
                );

                animating = false;
                document.getElementById('trainBtn').disabled = false;
                document.getElementById('forwardBtn').disabled = false;
            }

            async function startTraining() {
                if (animating) return;

                animating = true;
                document.getElementById('trainBtn').disabled = true;
                document.getElementById('forwardBtn').disabled = true;
                clearErrorAccumulator();

                let totalLoss = 0;

                if (learningMode === 'stochastic') {
                    updateStepIndicator(
                        'üéØ Stochastic Gradient Descent',
                        'Updating weights after EACH sample'
                    );

                    for (let i = 0; i < trainingData.length; i++) {
                        const sample = trainingData[i];

                        document.getElementById('phaseValue').textContent = `SGD ${i + 1}/4`;

                        updateStepIndicator(
                            `üì§ √âchantillon ${i + 1} : Passage avant`,
                            `Traitement : [${sample.input.map(v => v.toFixed(2)).join(', ')}]`
                        );

                        await forwardPropagate(sample.input, true);

                        const output = neurons[neurons.length - 1].map(n => n.activation);
                        const loss = calculateLoss(output, sample.target);
                        totalLoss += loss;

                        updateErrorAccumulator(i, loss, false);
                        document.getElementById('totalLoss').textContent = totalLoss.toFixed(4);

                        await sleep(500 / animationSpeed);
                        updateStepIndicator(
                            `üì• √âchantillon ${i + 1} : R√©tropropagation + Mise √† jour`,
                            `Mise √† jour imm√©diate des poids (SGD)`,
                            `Mise √† jour des poids n¬∞${totalWeightUpdates + 1}`
                        );

                        await backPropagate(sample.target, true, true); // true = update weights

                        updateErrorAccumulator(i, loss, true);

                        await sleep(700 / animationSpeed);
                    }

                } else {
                    // Mode par lot
                    updateStepIndicator(
                        'üì¶ Descente de gradient par lot',
                        'Accumulation des gradients de TOUS les √©chantillons'
                    );

                    for (let i = 0; i < trainingData.length; i++) {
                        const sample = trainingData[i];

                        document.getElementById('phaseValue').textContent = `Lot ${i + 1}/4`;

                        updateStepIndicator(
                            `üì§ √âchantillon ${i + 1} : Passage avant`,
                            `Traitement : [${sample.input.map(v => v.toFixed(2)).join(', ')}]`
                        );

                        await forwardPropagate(sample.input, true);

                        const output = neurons[neurons.length - 1].map(n => n.activation);
                        const loss = calculateLoss(output, sample.target);
                        totalLoss += loss;

                        updateErrorAccumulator(i, loss, false);
                        document.getElementById('totalLoss').textContent = totalLoss.toFixed(4);

                        await sleep(500 / animationSpeed);

                        updateStepIndicator(
                            `üì• √âchantillon ${i + 1} : R√©tropropagation (Accumulation)`,
                            `Stockage des gradients, PAS encore de mise √† jour`,
                            `Gradient accumul√© pour l'√©chantillon ${i + 1}`
                        );

                        await backPropagate(sample.target, true, false); // false = ne pas mettre √† jour encore

                        updateErrorAccumulator(i, loss, true);

                        await sleep(700 / animationSpeed);
                    }

                    // Appliquer maintenant la mise √† jour par lot
                    updateStepIndicator(
                        '‚ö° Application de la mise √† jour par lot',
                        'Mise √† jour de TOUS les poids avec la moyenne des gradients',
                        `Une seule mise √† jour des poids en utilisant la moyenne de ${trainingData.length} √©chantillons`
                    );

                    await sleep(1000 / animationSpeed);
                    applyBatchUpdate();
                    await sleep(1000 / animationSpeed);
                }

                currentLoss = totalLoss / trainingData.length;
                epochCount++;
                updateStats();

                updateStepIndicator(
                    'üéâ √âpoque termin√©e !',
                    `Mode : ${learningMode === 'stochastic' ? 'SGD (4 mises √† jour)' : 'Par lot (1 mise √† jour)'} | Perte moyenne : ${currentLoss.toFixed(4)}`,
                    `Mises √† jour des poids totales jusqu'√† pr√©sent : ${totalWeightUpdates}`
                );

                document.getElementById('phaseValue').textContent = 'Termin√©';

                animating = false;
                document.getElementById('trainBtn').disabled = false;
                document.getElementById('forwardBtn').disabled = false;
            }

            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            function resetNetwork() {
                if (animating) return;

                neurons.forEach(layer => {
                    layer.forEach(n => {
                        n.activation = 0;
                        n.delta = 0;
                        n.accumulatedDelta = 0;
                        n.computing = false;
                        n.weightedSum = 0;
                    });
                });

                connections.forEach(c => {
                    c.signal = 0;
                    c.backSignal = 0;
                    c.accumulatedGradient = 0;
                    c.active = false;
                });

                epochCount = 0;
                currentLoss = 0;
                totalWeightUpdates = 0;

                clearErrorAccumulator();
                document.getElementById('errorAccumulator').style.display = 'none';
                updateStats();
                updateStepIndicator('Pr√™t √† d√©marrer', 'S√©lectionnez un mode d\'apprentissage et cliquez sur "Entra√Æner le r√©seau"');
                document.getElementById('phaseValue').textContent = 'Pr√™t';

                drawNetwork();
            }

            function randomizeWeights() {
                if (animating) return;

                connections.forEach(conn => {
                    conn.weight = (Math.random() * 2 - 1) * 0.5;
                });

                resetNetwork();
                updateStepIndicator('Poids randomis√©s', 'R√©seau r√©initialis√© avec de nouveaux poids al√©atoires');
            }

            document.getElementById('speedSlider').addEventListener('input', (e) => {
                animationSpeed = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = animationSpeed.toFixed(1) + 'x';
            });

            initNetwork();
            drawNetwork();
        </script>
    </body>

</html>